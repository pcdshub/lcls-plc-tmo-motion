<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_PPM_RESPON" Id="{6e476e2b-3897-4a4a-889b-a4fd22502b33}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_PPM_RESPON EXTENDS FB_PPM
VAR_INPUT
    // Calibrated for each gentec, should be passed as input or set via pv
    // If not set, responsive energy will not be calculated
    {attribute 'pytmc' := '
        pv: Responsivity
        io: io
        field: EGU V/W
    '}
    fResponsivity: LREAL;
END_VAR
VAR_OUTPUT
END_VAR
VAR
    // Linked to beam rate
    {attribute 'pytmc' := '
        pv: BeamRateFromEpics
        link: TPG:SYS0:1:DST04:RATE
    '}
    fFrequency: UINT;
    // Pulse-by-pulse energy
    {attribute 'pytmc' := '
        pv: ResponMJ
        io: i
        field: EGU mJ
    '}
    fResponMJ: LREAL;
    // Pulse-by-pulse energy buffer
    {attribute 'pytmc' := '
        pv: ResponMJ_BUFFER
        io: i
        field: EGU mJ
    '}
    fResponMJBuffer: ARRAY[1..1000] OF LREAL;
    fbResponMJBuffer: FB_LREALBuffer;
    // Wattage
    {attribute 'pytmc' := '
        pv: ResponWattage
        io: i
        field: EGU W
    '}
    fResponWattage: LREAL;
    // Background voltage
    {attribute 'pytmc' := '
        pv: Background
        io: io
        field: EGU V
    '}
    fBackground: LREAL;
    // Boolean to trigger collection of background voltages
    {attribute 'pytmc' := '
        pv: BackgroundCollect
        io: i
    '}
    fBackgroundCollect: BOOL;

    {attribute 'pytmc' := '
        pv: BackgroundCollectionTime
        io: io
        field: EGU s
    '}
    // Time in seconds to collect background voltages for
    fBackgroundCollectionTime: UINT;
    // Number of cycles to collect background voltages for
    fBackgroundCollectionCycles: UDINT;
    // Number of cycles that background voltages have already been collected
    fBackgroundCollectionCyclesDone: UDINT;
    // Sum of background voltages, should only be used internally
    fBackgroundCollectionSum: LREAL;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[// Passing all inputs to FB_PPM
SUPER^(fbArbiter := fbArbiter,
    fbFFHWO := fbFFHWO,
    stYStage := stYStage,
    sDeviceName := sDeviceName,
    sTransitionKey := sTransitionKey,
    bEnableMotion := bEnableMotion,
    bEnableBeamParams := bEnableBeamParams,
    bEnablePositionLimits := bEnablePositionLimits,
    stOut := stOut,
    stPower := stPower,
    stYag1 := stYag1,
    stYag2 := stYag2,
    eEnumSet := eEnumSet,
    bReadDBNow := bReadDBNow,
    fFlowOffset := fFlowOffset
);
// (Re)starting backround collection, will gracefully restart
IF fBackgroundCollect = TRUE THEN
    fBackgroundCollect := FALSE;
    fBackgroundCollectionCycles := 10_000_000 * fBackgroundCollectionTime / _TaskInfo[GETCURTASKINDEXEX()].CycleTime;
    fBackgroundCollectionCyclesDone := 0;
    fBackgroundCollectionSum := 0;
END_IF
// Keeps a running average of background voltage
IF fBackgroundCollectionCycles <> 0 THEN
    fBackgroundCollectionSum := fBackgroundCollectionSum + fbPowerMeter.fVoltage;
    fBackgroundCollectionCycles := fBackgroundCollectionCycles - 1;
    fBackgroundCollectionCyclesDone := fBackgroundCollectionCyclesDone + 1;
    fBackground := fBackgroundCollectionSum / fBackgroundCollectionCyclesDone;
END_IF
// Getting wattage and energy
IF fResponsivity <> 0 AND fFrequency <> 0 THEN
    fResponWattage := (fbPowerMeter.fVoltage - fBackground) / fResponsivity;
    fResponMJ := fResponWattage / fFrequency;
END_IF
// Buffer for pulse-by-pulse energy
fbResponMJBuffer(
bExecute := TRUE,
fInput := fResponMJ,
arrOutput => fResponMJBuffer);]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>